{"/about/":{"data":{"":"rpxy [ahr-pik-see] is designed to be a high-performance, secure, and reliable HTTP reverse-proxy. It is built on top of the Rust programming language and Rust ecosystem libraries. rpxy is designed to be a drop-in replacement for the popular HTTP reverse proxies such as NGINX and Caddy, considering performance-focused environment.\nrpxy is built under the concepts of simple configuration, blazingly fast message handling, and secure by default. It is also designed to be a high-performance HTTP reverse-proxy that can handle a large number of concurrent connections with minimal resource usage.","credits#Credits":"rpxy cannot be built without the following projects and inspirations:\nhyper and hyperium/h3\nrustls\ntokio\nquinn\ns2n-quic\nrustls-acme"},"title":"About"},"/docs/":{"data":{"":" Getting Started Using Containers Configuration Options "},"title":"Documentation"},"/docs/configuration/":{"data":{"":"TBD"},"title":"Configuration Options"},"/docs/container/":{"data":{"":"TBD"},"title":"Using Containers"},"/docs/container/docker/":{"data":{"":"TBD"},"title":"Docker Images"},"/docs/guide/basics/":{"data":{"":"Here we explain some typical setups for rpxy. We will start with the most basic setup and gradually introduce more advanced features."},"title":"Basic Setups"},"/docs/guide/basics/cleartext/":{"data":{"":"Here we describe how to configure a simple reverse proxy server that forwards incoming cleartext HTTP requests to a backend application.","load-balancing-with-multiple-backend-locations#Load Balancing with Multiple Backend Locations":"You can specify multiple backend locations in the reverse_proxy array for load-balancing with an appropriate load_balance option. Currently it works with the following options:\nround_robin: for each request, one of the backend locations is chosen in a round-robin fashion; random: for each request, one of the backend locations is chosen randomly; sticky: a backend location is chosen as round_robin but the session-persistance is guaranteed using cookie. If load_balance is not specified, the first backend location is always chosen.\n[apps.\"app_name\"] server_name = 'app1.example.com' reverse_proxy = [ { location = 'app1.local:8080' }, { location = 'app2.local:8000' } ] load_balance = 'round_robin' # or 'random' or 'sticky' ℹ️ Currently, no health-checking mechanism is implemented. If a backend location is down, the request to the location will be failed. ","serving-multiple-domain-names#Serving Multiple Domain Names":"If you want to host multiple and distinct domain names in a single IP address/port, simply create multiple app.\"\u003capp_name\u003e\" entries in the config file like the following.\nlisten_port = 80 default_app = \"app1\" [apps.app1] server_name = \"app1.example.com\" reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] [apps.app2] server_name = \"app2.example.org\" reverse_proxy = [{ upstream = [{ location = 'app2.local:8888' }] }] In the above setting, by specifying default_app entry, any cleartext HTTP request will be served by the specified application if its HOST header or URL in Request line doesn’t match any server_names in reverse_proxy entries.\nℹ️ Any HTTPS request with no matched server_name will be rejected since the secure connection cannot be established for the unknown server name, i.e., Common Name of the server certificate. ","the-simplest-configuration#The Simplest Configuration":"The simplest configuration of the TOML-based configuration file, say config.toml, is given like the following.\nlisten_port = 80 [apps.app1] server_name = 'app1.example.com' reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] In the above setting, rpxy listens on port 80 (TCP) and serves incoming cleartext HTTP request including a app1.example.com in its HOST header or URL in its Request line, e.g., following HTTP request messages.\nGET http://app1.example.com/path/to HTTP/1.1\\r\\n or\nGET /path/to HTTP/1.1\\r\\n HOST: app1.example.com\\r\\n Otherwise, say, a request to other.example.com is simply rejected with the status code 40x.\nAlso in the above setting, the outgoing connection to the backend application is over cleartext HTTP, not HTTPS, as well as the incoming connection. If you need to forward the request to the backend application over HTTPS, see the following subsection.","upstream-connection-over-https-to-backend-application#Upstream Connection over HTTPS to Backend Application":"In the above example, request messages are routed to backend applications over cleartext HTTP. If a backend channel to an app needs to established over TLS, e.g., requests forwarded to https://app1.localdomain:8080, you need to enable a tls option for the location requiring HTTPS connection.\n[apps.app_backend_https] server_name = \"app_backend_https.example.com\" revese_proxy = [ { location = 'app1.localdomain:8080', tls = true } ] "},"title":"1. Cleartext HTTP Reverse Proxy"},"/docs/guide/basics/routing/":{"data":{"":"TBD"},"title":"3. More Flexible Routing Based on URL Path"},"/docs/guide/basics/tls/":{"data":{"":"TBD"},"title":"2. Terminating TLS"},"/docs/guide/cmdopt/":{"data":{"":"rpxy always requires a configuration file in TOML format, e.g., config.toml on GitHub repo.\nℹ️ The detailed configuration options are described in the Configuration Options section. You can run rpxy with a configuration file like\n% ./path/to/rpxy --config config.toml If you specify -w option along with the config file path, rpxy tracks the change of config.toml in the real-time manner and apply the change immediately without restarting the process.\nThe full help messages are given follows.\nusage: rpxy [OPTIONS] --config \u003cFILE\u003e Options: -c, --config \u003cFILE\u003e Configuration file path like ./config.toml -w, --watch Activate dynamic reloading of the config file via continuous monitoring -h, --help Print help -V, --version Print version That’s all!"},"title":"Command Line Options"},"/docs/guide/installation/":{"data":{"":"","building-from-source#Building from Source":"You can build an executable binary yourself by checking out this Git repository.\n# Cloning the git repository % git clone https://github.com/junkurihara/rust-rpxy % cd rust-rpxy # Update submodules % git submodule update --init # Build (default: QUIC and HTTP/3 is enabled using `quinn`) % cargo build --release # If you want to use `s2n-quic`, build as follows. You may need several additional dependencies. % cargo build --no-default-features --features http3-s2n --release Then you have an executive binary rust-rpxy/target/release/rpxy.","package-installation-for-linux-rpmdeb#Package Installation for Linux (RPM/DEB)":"You can find the Jenkins CI/CD build scripts for rpxy in the ./.build directory.\nPrebuilt packages for Linux RPM and DEB are available at https://rpxy.gamerboy59.dev, provided by @Gamerboy59.\nℹ️ Note that we do not have an option of installation via crates.io, i.e., cargo install, at this point since some dependencies are not published yet. Alternatively, you can use docker image (see Container section) as the easiest way for amd64 environment. "},"title":"Installation"}}