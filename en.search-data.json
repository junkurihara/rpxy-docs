{"/about/":{"data":{"":"rpxy [ahr-pik-see] is designed to be a high-performance, secure, and reliable HTTP reverse-proxy. It is built on top of the Rust programming language and Rust ecosystem libraries. rpxy is also designed to be a drop-in replacement for the popular HTTP reverse proxies such as NGINX and Caddy, considering performance-focused environment.\nrpxy is built under the concepts of simple configuration, blazingly fast message handling, and secure by default. It is also designed to be a high-performance HTTP reverse-proxy that can handle a large number of concurrent connections with minimal resource usage.","credits#Credits":"rpxy cannot be built without the following projects and inspirations:\nhyper and hyperium/h3\nrustls\ntokio\nquinn\ns2n-quic\nrustls-acme"},"title":"About"},"/docs/":{"data":{"":" Getting Started Using Containers Configuration Options TIPS "},"title":"Documentation"},"/docs/configuration/":{"data":{"":"TBD"},"title":"Configuration Options"},"/docs/container/":{"data":{"":"TBD"},"title":"Using Containers"},"/docs/container/docker/":{"data":{"":"TBD"},"title":"Docker Images"},"/docs/guide/":{"data":{"":"Here we guide you through the basic steps to get started with rpxy. We will start with the installation and gradually introduce more advanced features.\n1. Installation 2. Command Line Options 3. Basic Setups 4. Advanced Usage "},"title":"Getting Started"},"/docs/guide/advanced/":{"data":{"":" HTTP/3 TLS Client Authentication ACME (Let's Encrypt) Integration Caching "},"title":"Advanced Usage"},"/docs/guide/advanced/acme/":{"data":{"":"In addition to use static files of certificates and private keys, the automatic issuance and renewal of certificates, i.e., ACME (Automated Certificate Management Environment) standardized as RFC8555, are available in rpxy. To enable this feature, you need to specify the following entries for each application requiring ACME in the configuration file.\n# TLS port, which is also used for ACME challenge. listen_port_tls = 443 # ACME enabled domain name. # Note that acme option must be specified in the experimental section. [apps.\"app_with_acme\"] server_name = 'example.org' reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] tls = { https_redirection = true, acme = true } # do not specify tls_cert_path and/or tls_cert_key_path ACME will be used to get a certificate for the server_name with ACME TLS-ALPN-01 (RFC8737) protocol. So all you need is to open the TLS port 443 to the public. Also in this case, you don’t need to specify tls_cert_path and tls_cert_key_path for the application.\nFor every ACME enabled domain, the following settings are referred to acquire a certificate and a private key.\n# Global ACME settings. Unless specified, ACME is disabled. [experimental.acme] # Email address for ACME registration. email = \"test@example.com\" # Optional: ACME directory URL. [default: \"https://acme-v02.api.letsencrypt.org/directory\"] dir_url = \"https://acme-staging-v02.api.letsencrypt.org/directory\" # Optional: Directory storing retrieved certificates and private keys, which is relative to the current working directory. [default: \"./acme_registry\"] registry_path = \"./acme_registry\" The above configuration is common to all ACME enabled domains. Note that the https port must be open to the public to prove the domain ownership.\n⚠️ This is a brand-new feature and maybe still unstable. "},"title":"ACME (Let's Encrypt) Integration"},"/docs/guide/advanced/cache/":{"data":{"":"rpxy takes an approach to cache responses in a hybrid way of temporary files and on-memory objects. If [experimental.cache] is specified in config.toml, you can leverage the local caching feature using temporary files and on-memory objects. An example configuration is as follows.\n# If this specified, file cache feature is enabled [experimental.cache] cache_dir = './cache' # optional. default is \"./cache\" relative to the current working directory max_cache_entry = 1000 # optional. default is 1k max_cache_each_size = 65535 # optional. default is 64k max_cache_each_size_on_memory = 4096 # optional. default is 4k if 0, it is always file cache. A storable (in the context of an HTTP message) response is stored if its size is less than or equal to max_cache_each_size in bytes. If it is also less than or equal to max_cache_each_size_on_memory, it is stored as an on-memory object. Otherwise, it is stored as a temporary file. Note that max_cache_each_size must be larger or equal to max_cache_each_size_on_memory.\nℹ️ Once rpxy restarts or the config is updated, the cache is totally eliminated not only from the on-memory table but also from the file system. "},"title":"Caching"},"/docs/guide/advanced/client_auth/":{"data":{"":"TLS client authentication is enabled when apps.\"app_name\".tls.client_ca_cert_path is set for the domain specified by \"app_name\" like\n[apps.localhost] server_name = 'localhost' # Domain name tls = { https_redirection = true, tls_cert_path = './server.crt', tls_cert_key_path = './server.key', client_ca_cert_path = './client_cert.ca.crt' } ⚠️ Currently we have a limitation on HTTP/3 support for applications that enables client authentication. If an application is set with client authentication, HTTP/3 doesn’t work for the application. "},"title":"TLS Client Authentication"},"/docs/guide/advanced/http3/":{"data":{"":"rpxy can serve HTTP/3 requests thanks to quinn, s2n-quic and hyperium/h3. To enable this experimental feature, add an entry experimental.h3 in your config.toml like follows. Then, any TLS-enabled application can be served with HTTP/3 in addition to HTTP/2 and HTTP/1.1 except for the applications with TLS client authentication.\n[experimental.h3] alt_svc_max_age = 3600 request_max_body_size = 65536 max_concurrent_connections = 10000 max_concurrent_bidistream = 100 max_concurrent_unistream = 100 max_idle_timeout = 10 ℹ️ Any values in the entry like alt_svc_max_age are optional. "},"title":"HTTP/3"},"/docs/guide/basics/":{"data":{"":"Here we explain some typical setups for rpxy. We will start with the most basic setups.\n1. Cleartext HTTP 2. TLS Termination 3. Routing Wwe frequently add new options for rpxy configuration. Then, we first add new option entries in Configuration Options section and the config-example.toml file. So please refer to them for up-to-date options."},"title":"Basic Setups"},"/docs/guide/basics/1_cleartext/":{"data":{"":"Here we describe how to configure a simple reverse proxy server that forwards incoming cleartext HTTP requests to a backend application.","load-balancing-with-multiple-backend-locations#Load Balancing with Multiple Backend Locations":"You can specify multiple backend locations in the reverse_proxy array for load-balancing with an appropriate load_balance option. Currently it works with the following options:\nround_robin: for each request, one of the backend locations is chosen in a round-robin fashion; random: for each request, one of the backend locations is chosen randomly; sticky: a backend location is chosen as round_robin but the session-persistance is guaranteed using cookie. If load_balance is not specified, the first backend location is always chosen.\n[apps.\"app_name\"] server_name = 'app1.example.com' reverse_proxy = [ { location = 'app1.local:8080' }, { location = 'app2.local:8000' } ] load_balance = 'round_robin' # or 'random' or 'sticky' ℹ️ Currently, no health-checking mechanism is implemented. If a backend location is down, the request to the location will be failed. ","serving-multiple-domain-names#Serving Multiple Domain Names":"If you want to host multiple and distinct domain names in a single IP address/port, simply create multiple app.\"\u003capp_name\u003e\" entries in the config file like the following.\nlisten_port = 80 default_app = \"app1\" [apps.app1] server_name = \"app1.example.com\" reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] [apps.app2] server_name = \"app2.example.org\" reverse_proxy = [{ upstream = [{ location = 'app2.local:8888' }] }] In the above setting, by specifying default_app entry, any cleartext HTTP request will be served by the specified application if its HOST header or URL in Request line doesn’t match any server_names in reverse_proxy entries.\nℹ️ Any HTTPS request with no matched server_name will be rejected since the secure connection cannot be established for the unknown server name, i.e., Common Name of the server certificate. ","the-simplest-configuration#The Simplest Configuration":"The simplest configuration of the TOML-based configuration file, say config.toml, is given like the following.\nlisten_port = 80 [apps.app1] server_name = 'app1.example.com' reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] In the above setting, rpxy listens on port 80 (TCP) and serves incoming cleartext HTTP request including a app1.example.com in its HOST header or URL in its Request line, e.g., following HTTP request messages.\nGET http://app1.example.com/path/to HTTP/1.1\\r\\n or\nGET /path/to HTTP/1.1\\r\\n HOST: app1.example.com\\r\\n Otherwise, say, a request to other.example.com is simply rejected with the status code 40x.\nAlso in the above setting, the outgoing connection to the backend application is over cleartext HTTP, not HTTPS, as well as the incoming connection. If you need to forward the request to the backend application over HTTPS, see the following subsection.","upstream-connection-over-https-to-backend-application#Upstream Connection over HTTPS to Backend Application":"In the above example, request messages are routed to backend applications over cleartext HTTP. If a backend channel to an app needs to established over TLS, e.g., requests forwarded to https://app1.localdomain:8080, you need to enable a tls option for the location requiring HTTPS connection.\n[apps.app_backend_https] server_name = \"app_backend_https.example.com\" revese_proxy = [ { location = 'app1.localdomain:8080', tls = true } ] "},"title":"1. Cleartext HTTP Reverse Proxy"},"/docs/guide/basics/2_tls/":{"data":{"":"Here we describe how to terminate TLS in rpxy. In the following, we show how to specify existing TLS certificates and private keys. We also show how to redirect incoming cleartext HTTP requests to HTTPS.\nℹ️ The integration with ACME (Let’s Encrypt) is described in the advanced section. First of all, you need to specify a port listen_port_tls listening the HTTPS traffic, separately from HTTP port (listen_port) in the configuration file.\nlisten_port = 80 listen_port_tls = 443 ","redirecting-cleartext-http-requests-to-https#Redirecting Cleartext HTTP Requests to HTTPS":"In the current Web, we believe it is common to serve everything through HTTPS rather than HTTP, and hence https redirection is often used for HTTP requests. When you specify both listen_port and listen_port_tls, you can enable an option of such redirection by making https_redirection true.\ntls = { https_redirection = true, tls_cert_path = 'server.crt', tls_cert_key_path = 'server.key' } If it is true, rpxy returns the status code 301 to the cleartext request with new location https://\u003crequested_host\u003e/\u003crequested_query_and_path\u003e served over TLS.","using-existing-tls-certificates#Using Existing TLS Certificates":"Suppose that you have a TLS certificate and a private key in PEM format, and that you want to use them for serving HTTPS traffic. Then, serving an HTTPS endpoint can be easily done for your desired application just by specifying TLS certificates and private keys in PEM files.\nlisten_port = 80 listen_port_tls = 443 [apps.\"app_name\"] server_name = 'app1.example.com' tls = { tls_cert_path = 'server.crt', tls_cert_key_path = 'server.key' } reverse_proxy = [{ upstream = [{ location = 'app1.local:8080' }] }] In the above setting, both cleartext HTTP requests to port 80 and ciphertext HTTPS requests to port 443 are routed to the backend app1.local:8080 in the same fashion. If you don’t need to serve cleartext requests, just remove listen_port = 80 and specify only listen_port_tls = 443.\nℹ️ We should note that the private key specified by tls_cert_key_path must be in PKCS8 format. (See TIPS to convert a PKCS1 formatted private key to PKCS8 one.) "},"title":"2. Terminating TLS"},"/docs/guide/basics/3_routing/":{"data":{"":"rpxy can serves and routes incoming requests to multiple backend destination according to the path information. The routing information can be specified for each application (server_name) as follows.\nlisten_port_tls = 443 [apps.app1] server_name = 'app1.example.com' tls = { https_redirection = true, tls_cert_path = 'server.crt', tls_cert_key_path = 'server.key' } [[apps.app1.reverse_proxy]] upstream = [ { location = 'default.backend.local' } ] [[apps.app1.reverse_proxy]] path = '/path' upstream = [ { location = 'path.backend.local' } ] [[apps.app1.reverse_proxy]] path = '/path/another' replace_path = '/path' upstream = [ { location = 'another.backend.local' } ] In the above example, a request to\nhttps://app1.example.com/path/to?query=ok matches the second reverse_proxy entry in the longest-prefix-matching manner, and will be routed to path.backend.local with preserving path and query information, i.e., served as\nhttp://path.backend.local/path/to?query=ok On the other hand, a request to\nhttps://app1.example.com/path/another/xx?query=ng matching the third entry is routed with being rewritten its path information specified by replace_path option. Namely, the matched /path/another part is rewritten with /path, and it is served as\nhttp://another.backend.local/path/xx?query=ng Requests that doesn’t match any paths will be routed by the first entry that doesn’t have the path option, which means the default destination. In other words, if every reverse_proxy entry has an explicit path option, rpxy rejects requests that don’t match any paths.","simple-path-based-routing-example#Simple Path-based Routing Example":"This path-based routing option would be enough in many cases. For example, you can serve multiple applications with one domain by specifying unique path to each application. More specifically, see the following example.\n[apps.app] server_name = 'app.example.com' #... [[apps.app.reverse_proxy]] path = '/subapp1' replace_path = '/' upstream = [ { location = 'subapp1.local' } ] [[apps.app.reverse_proxy]] path = '/subapp2' replace_path = '/' upstream = [ { location = 'subapp2.local' } ] [[apps.app.reverse_proxy]] path = '/subapp3' replace_path = '/' upstream = [ { location = 'subapp3.local' } ] This example configuration explains a very frequent situation of path-based routing. When a request to app.example.com/subappN routes to sbappN.local by replacing a path part /subappN to /."},"title":"3. Path-based Flexible Routing"},"/docs/guide/cmdopt/":{"data":{"":"rpxy always requires a configuration file in TOML format, e.g., config.toml on GitHub repo.\nℹ️ We will introduce some typical configurations in the Basic Setups and Advanced Usage sections. The detailed configuration options are described in the Configuration Options section. You can run rpxy with a configuration file like\n% ./path/to/rpxy --config config.toml If you specify -w option along with the config file path, rpxy tracks the change of config.toml in the real-time manner and apply the change immediately without restarting the process.\nThe full help messages are given follows.\nusage: rpxy [OPTIONS] --config \u003cFILE\u003e Options: -c, --config \u003cFILE\u003e Configuration file path like ./config.toml -w, --watch Activate dynamic reloading of the config file via continuous monitoring -h, --help Print help -V, --version Print version That’s all!"},"title":"Command Line Options"},"/docs/guide/installation/":{"data":{"":"","building-from-source#Building from Source":"You can build an executable binary yourself by checking out this Git repository.\n# Cloning the git repository % git clone https://github.com/junkurihara/rust-rpxy % cd rust-rpxy # Update submodules % git submodule update --init # Build (default: QUIC and HTTP/3 is enabled using `quinn`) % cargo build --release # If you want to use `s2n-quic`, build as follows. You may need several additional dependencies. % cargo build --no-default-features --features http3-s2n --release Then you have an executive binary rust-rpxy/target/release/rpxy.","package-installation-for-linux-rpmdeb#Package Installation for Linux (RPM/DEB)":"You can find the Jenkins CI/CD build scripts for rpxy in the ./.build directory.\nPrebuilt packages for Linux RPM and DEB are available at https://rpxy.gamerboy59.dev, provided by @Gamerboy59.\nℹ️ Note that we do not have an option of installation via crates.io, i.e., cargo install, at this point since some dependencies are not published yet. Alternatively, you can use docker image (see Container section) as the easiest way for amd64 environment. "},"title":"Installation"},"/docs/tips/":{"data":{"":"","client-authentication-using-client-certificate-signed-by-your-own-root-ca#Client Authentication using Client Certificate Signed by Your Own Root CA":"","managing-rpxy-via-web-interface#Managing \u003ccode\u003erpxy\u003c/code\u003e via web interface":"Set custom port for HTTPS redirection Consider a case where rpxy is running on a container. Then when the container manager maps port A (e.g., 80/443) of the host to port B (e.g., 8080/8443) of the container for http and https, rpxy must be configured with port B for listen_port and listen_port_tls. However, when you want to set http_redirection=true for some backend apps, rpxy issues the redirection response 301 with the port B by default, which is not accessible from the outside of the container. To avoid this, you can set a custom port for the redirection response by specifying https_redirection_port in config.toml. In this case, port A should be set for https_redirection_port, then the redirection response 301 will be issued with the port A.\nlisten_port = 8080 listen_port_tls = 8443 https_redirection_port = 443 Using Private Key Issued by Let’s Encrypt If you obtain certificates and private keys from Let’s Encrypt, you have PKCS1-formatted private keys. So you need to convert such retrieved private keys into PKCS8 format to use in rpxy.\nThe easiest way is to use openssl by\n% openssl pkcs8 -topk8 -nocrypt \\ -in yoru_domain_from_le.key \\ -inform PEM \\ -out your_domain_pkcs8.key.pem \\ -outform PEM Client Authentication using Client Certificate Signed by Your Own Root CA First, you need to prepare a CA certificate used to verify client certificate. If you do not have one, you can generate CA key and certificate by OpenSSL commands as follows. Note that rustls accepts X509v3 certificates and reject SHA-1, and that rpxy relys on Version 3 extension fields of KeyIDs of Subject Key Identifier and Authority Key Identifier.\nGenerate CA key of secp256v1, CSR, and then generate CA certificate that will be set for tls.client_ca_cert_path for each server app in config.toml. % openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out client.ca.key % openssl req -new -key client.ca.key -out client.ca.csr ... ----- Country Name (2 letter code) []: ... State or Province Name (full name) []: ... Locality Name (eg, city) []: ... Organization Name (eg, company) []: ... Organizational Unit Name (eg, section) []: ... Common Name (eg, fully qualified host name) []: \u003cShould not input CN\u003e Email Address []: ... % openssl x509 -req -days 3650 -sha256 -in client.ca.csr -signkey client.ca.key -out client.ca.crt -extfile client.ca.ext Generate a client key of secp256v1 and certificate signed by CA key. % openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:prime256v1 -out client.key % openssl req -new -key client.key -out client.csr ... ----- Country Name (2 letter code) []: State or Province Name (full name) []: Locality Name (eg, city) []: Organization Name (eg, company) []: Organizational Unit Name (eg, section) []: Common Name (eg, fully qualified host name) []: \u003cShould not input CN\u003e Email Address []: % openssl x509 -req -days 365 -sha256 -in client.csr -CA client.ca.crt -CAkey client.ca.key -CAcreateserial -out client.crt -extfile client.ext Now you have a client key client.key and certificate client.crt (version 3). pfx (p12) file can be retrieved as\n% openssl pkcs12 -export -inkey client.key -in client.crt -certfile client.ca.crt -out client.pfx Note that on MacOS, a pfx generated by OpenSSL 3.0.6 cannot be imported to MacOS KeyChain Access. We generated the sample pfx using LibreSSL 2.8.3 instead OpenSSL.\nAll of sample certificate files are found in ./example-certs/ directory.\n(Work Around) Deployment on Ubuntu 22.04LTS using docker behind ufw Basically, docker automatically manage your iptables if you use the port-mapping option, i.e., --publish for docker run or ports in docker-compose.yml. This means you do not need to manually expose your port, e.g., 443 TCP/UDP for HTTPS, using ufw-like management command.\nHowever, we found that if you want to use the brand-new UDP-based protocol, HTTP/3, on rpxy, you need to explicitly expose your HTTPS port by using ufw-like command.\n% sudo ufw allow 443 % sudo ufw enable Your docker container can receive only TCP-based connection, i.e., HTTP/2 or before, unless you manually manage the port. We see that this is weird and expect that it is a kind of bug (of docker? ubuntu? or something else?). But at least for Ubuntu 22.04LTS, you need to handle it as above.\nManaging rpxy via web interface Check a third party project Gamerboy59/rpxy-webui to manage rpxy via web interface.","set-custom-port-for-https-redirection#Set custom port for HTTPS redirection":"","using-private-key-issued-by-lets-encrypt#Using Private Key Issued by Let\u0026rsquo;s Encrypt":"","work-around-deployment-on-ubuntu-2204lts-using-docker-behind-ufw#(Work Around) Deployment on Ubuntu 22.04LTS using docker behind \u003ccode\u003eufw\u003c/code\u003e":""},"title":"TIPS"}}